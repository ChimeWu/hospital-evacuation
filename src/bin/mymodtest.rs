fn main(){
    let a = long();
    println!("{}", a);
    let b = MyStruct::new(1, 2);
     
    let s = String::from("hello");
    let c = b.haha(&s);

    println!("{}",c);
}


fn long() -> &'static str {
    "long"
}

struct MyStruct {
    a: i32,
    b: i32,
}

impl MyStruct {
    fn new(a: i32, b: i32) -> MyStruct {
        MyStruct { a, b }
    }

    fn haha<'a>(&'a self, s: &'a str) -> &'a str {
        println!("{}", self.a);
        s
    }
}

//生命周期参数被引用携带，但它标记的是引用指向的值的生命长度，而不是引用本身的生命长度。
//函数签名和结构体中的生命周期参数，参与构成的是“类型”，而不是“值”，生命周期参数本身是泛型参数，也就是说
//它是一个占位符，只有在实例化的时候才会被具体的生命周期替换。
//而具体的生命周期的长度是任意的，这个标签本身并不会影响具体的生命周期的长度，它代表着一种约束规则
//当我们传参时，我们实例化了这个引用类型，使得这个被引用的值与标签'a绑定
//当我们使用这个带有'a标签的引用时，我们检查与'a标签绑定的值，如果这个值依然存在，那么这个引用就是有效的
//如果这个值已经被销毁了，那么这个引用就是无效的
//而我们在函数签名中使用这种标签的目的，是为了表达多个引用之间的关系，进行约束
//这种约束是在编译期间进行的，而不是在运行期间进行的
//如何编写这种约束，取决于我们的需求